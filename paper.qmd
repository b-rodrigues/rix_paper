---
title: "Reproducible development environments with rix"
format:
    jss-pdf:
        keep-tex: true
    jss-html: default
author:
  - name: Bruno Rodrigues 
    affiliations:
      - name: Ministry of Research and Higher education, Luxembourg 
        department: Department of Statistics
        address: 18, Montée de la Pétrusse
        city: Luxembourg 
        country: Luxembourg 
        postal-code: 2327
      - Journal of Statistical Software
    orcid: 0000-0002-3211-3689
    email: bruno@brodrigues.co
    url: https://www.brodrigues.co 
  - name: Philipp Baumann
    affiliations:
      - Plus Affiliation
abstract: |
  In order to create an analysis that is easily reproducible,
  it is not enough to write clean code and document it well. One
  must also make sure to list all the dependencies of the analysis
  clearly and ideally provide an easy way to install said dependencies.
  There are several tools that can be used to list dependencies and to
  make them easily installable by someone that wishes to reproduce a study,
  such as Docker, a containerization solution. This paper will present
  the Nix package manager, and an R package called {rix} that lowers
  Nix's learning curve for users of the R programming language.

keywords: [reproducibility, R, Nix]
keywords-formatted: [reproducibility, "[R]{.proglang}", "[Nix]{.proglang}"]

bibliography: bibliography.bib  
---

## Introduction: Reproducibility is also about software {#sec-intro}

::: callout
The introduction is in principle "as usual". However, it should usually embed both the implemented *methods* and the *software* into the respective relevant literature. For the latter both competing and complementary software should be discussed (within the same software environment and beyond), bringing out relative (dis)advantages. All software mentioned should be properly `@cited`'d. (See also [Using BibTeX] for more details on {{< bibtex >}}.)

For writing about software JSS requires authors to use the markup `[]{.proglang}` (programming languages and large programmable systems), `[]{.pkg}` (software packages), back ticks like \`code\` for code (functions, commands, arguments, etc.).

If there is such markup in (sub)section titles (as above), a plain text version has to be provided in the {{< latex >}} command as well. Below we also illustrate how abbrevations should be introduced and citation commands can be employed. See the {{< latex >}} code for more details.
:::

@peng2011 introduced the idea of reproducibility being on a continuum: on one of
the ends of this continuum, we only have access to the paper describing the
studies, which is not reproducible at all. Then, if in addition, to this paper
we make the original source code of the analysis that was written to compute the
results of the study available, reproducibility is improved, albeit only by a
little. Adding the original data improves reproducibility yet again. Finally, if
to all this we add what Roger Peng named the *linked and executable code and
data*, we reach the gold standard of full replication.

What is this *linked and executable code and data*? Another way to name this
crucial piece of the reproducibility puzzle is *computational environment*. The
computational environment is all the software required to actually run the
analysis. Here too, we can speak of a continuum. One could simply name and list
the software used: for example, the [R]{.proglang} programming language.
Sometimes, authors have the courtesy to also state the version of [R]{.proglang}
used. Some authors go further, and also list the packages used, and ideally with
their versions as well. Authors rarely state the operating system on which the
analysis was done, even though it has been shown that running the same analysis
with the same software but on different operating systems could lead to different
results, as described in @neupane2019. Authors also only very rarely provide
instructions to install the required tools and software in order to reproduce
their studies.

There are exceptions of course, a great example of a paper that provides everything
needed to reproduce its results is @mcdermott2021. The author of this paper set up
an accompagnying Github repository to the paper^[https://github.com/grantmcdermott/skeptic-priors]
containing all the instructions to install the required software and then run the
analysis. If we take a closer look at this repository, we will notice that several
tools were used to capture the compatutational environment and make it available to
other researchers:

- The version of [R]{.proglang} was stated;
- Packages and their versions were listed and saved into an `renv.lock` file;
- A `Makefile` was used to run the whole analysis and compile the paper;
- A `Dockerfile` was used to provide the complete computational environment, including the right version of [R]{.proglang} and run the whole analysis easily.

As we go down this list, we get closer to the gold standard of a perfectly reproducible
study.

However, reaching this gold standard is quite costly: one needs to learn a tool
to deal with package versions, then a build automation tool such as
[make]{.proglang} and ideally [Docker]{.proglang} should be added to the list.
[Docker]{.proglang} is a tool that makes it possible to run arbitrary code in a
completely controlled and isolated environment as a way to capture the complete
underlying system libraries.


### Prior art {#subsec-prior}




[R]{.proglang} provides a very flexible implementation of the general GLM framework in the function [glm]{.fct} @ChambersHastie1992 in the [stats]{.pkg} package. Its most important arguments are

```r
glm(formula, data, subset, na.action, weights, offset,
  family = gaussian, start = NULL, control = glm.control(…),
  model = TRUE, y = TRUE, x = FALSE, …)
```

where `formula` plus `data` is the now standard way of specifying regression relationships in [R]{.proglang}/[S]{.proglang} introduced in @ChambersHastie1992. The remaining arguments in the first line (`subset`, `na.action`, `weights`, and `offset`) are also standard for setting up formula-based regression models in [R]{.proglang}/[S]{.proglang}. The arguments in the second line control aspects specific to GLMs while the arguments in the last line specify which components are returned in the fitted model object (of class [glm]{.class} which inherits from [lm]{.class}). For further arguments to [glm]{.fct} (including alternative specifications of starting values) see `?glm`. For estimating a Poisson model `family = poisson` has to be specified.

::: callout
As the synopsis above is a code listing that is not meant to be executed, one can use either the dedicated `{Code}` environment or a simple `{verbatim}` environment for this. Again, spaces before and after should be avoided.

Finally, there might be a reference to a `{table}` such as @tbl-overview. Usually, these are placed at the top of the page (`[t!]`), centered (`\centering`), with a caption below the table, column headers and captions in sentence style, and if possible avoiding vertical lines.
:::

| Type           | Distribution | Method   | Description                                                                                                                                                                                  |
|---------|---------|---------|-----------------------------------------------|
| GLM            | Poisson      | ML       | Poisson regression: classical GLM, estimated by maximum likelihood (ML)                                                                                                                      |
|                |              | Quasi    | "Quasi-Poisson regression'': same mean function, estimated by quasi-ML (QML) or equivalently generalized estimating equations (GEE), inference adjustment via estimated dispersion parameter |
|                |              | Adjusted | "Adjusted Poisson regression'': same mean function, estimated by QML/GEE, inference adjustment via sandwich covariances                                                                      |
|                | NB           | ML       | NB regression: extended GLM, estimated by ML including additional shape parameter                                                                                                            |
| Zero-augmented | Poisson      | ML       | Zero-inflated Poisson (ZIP), hurdle Poisson                                                                                                                                                  |
|                | NB           | ML       | Zero-inflated NB (ZINB), hurdle NB                                                                                                                                                           |
: Overview of various count regression models. The table is usually placed at the top of the page (`[t!]`), centered (`centering`), has a caption below the table, column headers and captions are in sentence style, and if possible vertical lines should be avoided. {#tbl-overview}

## Illustrations {#sec-illustrations}

For a simple illustration of basic Poisson and NB count regression the
`quine` data from the [MASS]{.pkg} package is used. This provides the number
of `Days` that children were absent from school in Australia in a
particular year, along with several covariates that can be employed as regressors. The data can be loaded by

```{R}
#| prompt: true
data(mtcars)
```
and a basic frequency distribution of the response variable is displayed in
@fig-quine.

:::{.callout}
For code input and output, the style files provide dedicated environments.
Either the "agnostic" `{CodeInput}` and `{CodeOutput}` can be used
or, equivalently, the environments `{Sinput}` and `{Soutput}` as
produced by [Sweave]{.fct} or [knitr]{.pkg} when using the `render_sweave()`
hook. Please make sure that all code is properly spaced, e.g., using
`y = a + b * x` and _not_ `y=a+b*x`. Moreover, code input should use "the usual" command prompt in the respective software system. For
[R]{.proglang} code, the prompt `R> ` should be used with `+  ` as
the continuation prompt. Generally, comments within the code chunks should be
avoided -- and made in the regular {{< latex >}} text instead. Finally, empty lines before and after code input/output should be avoided (see above).
:::


## Summary and discussion {#sec-summary}

:::{.callout}

As usual…

:::

## Computational details {.unnumbered}

:::{.callout}

If necessary or useful, information about certain computational details
such as version numbers, operating systems, or compilers could be included
in an unnumbered section. Also, auxiliary packages (say, for visualizations,
maps, tables, …) that are not cited in the main text can be credited here.

:::

The results in this paper were obtained using [R]{.proglang}~3.4.1 with the
[MASS]{.pkg}~7.3.47 package. [R]{.proglang} itself and all packages used are available from the Comprehensive [R]{.proglang} Archive Network (CRAN) at
[https://CRAN.R-project.org/].


## Acknowledgments {.unnumbered}

:::{.callout}

All acknowledgments (note the AE spelling) should be collected in this
unnumbered section before the references. It may contain the usual information
about funding and feedback from colleagues/reviewers/etc. Furthermore,
information such as relative contributions of the authors may be added here
(if any).

:::

## References {.unnumbered}

:::{#refs}

:::

{{< pagebreak >}}

## More technical details {#sec-techdetails .unnumbered}

:::{.callout}

Appendices can be included after the bibliography (with a page break). Each
section within the appendix should have a proper section title (rather than
just _Appendix_).

For more technical style details, please check out JSS's style FAQ at
[https://www.jstatsoft.org/pages/view/style#frequently-asked-questions]
which includes the following topics:

- Title vs. sentence case.
- Graphics formatting.
- Naming conventions.
- Turning JSS manuscripts into [R]{.proglang} package vignettes.
- Trouble shooting.
- Many other potentially helpful details…

:::

## Using BibTeX {#sec-bibtex .unnumbered}

:::{.callout}

References need to be provided in a {{< bibtex >}} file (`.bib`). All
references should be made with `@cite` syntax. This commands yield different
formats of author-year citations and allow to include additional details (e.g.,pages, chapters, \dots) in brackets. In case you are not familiar with these
commands see the JSS style FAQ for details.

Cleaning up {{< bibtex >}} files is a somewhat tedious task -- especially
when acquiring the entries automatically from mixed online sources. However,
it is important that informations are complete and presented in a consistent
style to avoid confusions. JSS requires the following format.

- item JSS-specific markup (`\proglang`, `\pkg`, `\code`) should be used in the references.
- item Titles should be in title case.
- item Journal titles should not be abbreviated and in title case.
- item DOIs should be included where available.
- item Software should be properly cited as well. For [R]{.proglang} packages `citation("pkgname")` typically provides a good starting point.

:::


